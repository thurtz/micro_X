#!/usr/bin/env python

import os
import datetime
import subprocess # For running other utility scripts
import sys # For using sys.executable
import argparse # For command-line arguments
import re # For log parsing

# --- Configuration ---
# Files and directories to include in the snapshot.
# Paths are relative to the project root (where this script's parent directory is).
FILES_TO_INCLUDE = [
    "main.py",
    "config/default_config.json",
    "config/default_command_categories.json",
    "config/.tmux.conf",
    "requirements.txt",
    "requirements-dev.txt",
    ".gitignore",
    "utils/generate_tree.py",
    "utils/generate_snapshot.py", # Include self
    "utils/install_requirements.py",
    "utils/run_tests.py",
    "project_tree.txt", # Generated by generate_tree.py
    "README.md",
    "micro_X.sh",
    "micro_X.desktop",
    "modules/ai_handler.py",
    "modules/category_manager.py",
    "modules/output_analyzer.py",
    "modules/ollama_manager.py",
    "modules/shell_engine.py",
    "modules/ui_manager.py",
    "modules/git_context_manager.py",
    "setup_scripts/setup_micro_X_mac.sh",
    "setup_scripts/setup_micro_X_mint.sh",
    "setup_scripts/setup_micro_X_termux.sh",
    "setup_scripts/setup_micro_X_wsl.sh",
    "tests/test_ai_handler.py",
    "tests/test_category_manager.py",
    "tests/conftest.py",
    "tests/test_ui_manager.py",
    "tests/test_shell_engine.py",
    "tests/test_git_context_manager.py",
    "tests/test_main_startup.py",
    "tests/tests.md",
    "pytest_results/pytest_results.txt", # Generated by run_tests.py
    "docs/micro_X_User_Guide.md",
    "docs/setup_micro_X_mac.md",
    "docs/setup_micro_X_mint.md",
    "docs/setup_micro_X_termux.md",
    "docs/setup_micro_X_wsl.md",
    "docs/review_of_micro_X_project.md",
    "docs/micro_X_testing_guide.md",
    "setup.sh"
]

# Output directory and filename for the snapshot
SNAPSHOT_DIRECTORY = "snapshots"
SNAPSHOT_FILENAME_TEMPLATE = "micro_x_context_snapshot_{timestamp}.txt"

# Log file details (relative to project root)
LOG_DIR_NAME = "logs"
LOG_FILE_BASENAME = "micro_x.log"

# Log message content markers (these are the exact strings logged by logger.info())
LOG_SEPARATOR_LINE_TEXT = "=" * 68
LOG_SESSION_START_TEXT = " micro_X Session Started" # Note leading space
LOG_SESSION_END_TEXT = " micro_X Session Ended"   # Note leading space
LOG_TIMESTAMP_PREFIX_TEXT = " Timestamp: "       # Note leading space

# Regex to extract the message part from a log line
# Matches: YYYY-MM-DD HH:MM:SS,ms - LEVEL - module.py:line - Actual Message
# Allows for filenames like <stdin> or module.sub_module.py
LOG_MESSAGE_CAPTURE_PATTERN = re.compile(
    r"^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2},\d{3}\s*-\s*"
    r"(?:INFO|DEBUG|WARNING|ERROR|CRITICAL)\s*-\s*"
    r"[\w\.<>-]+:\d+\s*-\s*(.*)$"
)

# --- Helper Functions ---
def get_project_root():
    """Determines the project root directory.
    Assumes this script is in a 'utils' subdirectory of the project root.
    """
    script_path = os.path.abspath(__file__)
    utils_dir = os.path.dirname(script_path)
    project_root = os.path.dirname(utils_dir)
    # Check for common project root indicators
    if os.path.exists(os.path.join(project_root, "main.py")) or \
       os.path.exists(os.path.join(project_root, ".git")) or \
       os.path.isdir(os.path.join(project_root, "modules")):
        return project_root
    else:
        # Fallback if script is not in 'utils/' or structure is unexpected
        if os.path.exists(os.path.join(utils_dir, "main.py")) or \
           os.path.exists(os.path.join(utils_dir, ".git")) or \
           os.path.isdir(os.path.join(utils_dir, "modules")):
            print("Warning: Script might be in project root, not utils/. Assuming current dir is root.")
            return utils_dir
        print(f"Warning: Could not reliably determine project root. Using script's parent directory: {project_root}")
        return project_root


def read_file_content(filepath):
    """Reads the content of a file. Returns None if file not found or error."""
    try:
        with open(filepath, 'r', encoding='utf-8', errors='replace') as f:
            return f.read()
    except FileNotFoundError:
        print(f"Warning: File not found - {filepath}")
        return None
    except Exception as e:
        print(f"Warning: Error reading file {filepath} - {e}")
        return None

def run_utility_script(script_name: str, project_root: str, utils_dir: str) -> tuple[bool, str]:
    """
    Runs a utility script from the utils directory.
    Returns a tuple: (success: bool, message: str)
    """
    script_path = os.path.join(utils_dir, script_name)
    if not os.path.exists(script_path):
        message = f"Utility script '{script_name}' not found at '{script_path}'. Skipping."
        print(f"Warning: {message}")
        return False, f"[NOTICE: {script_name} execution skipped - script not found.]\n"

    print(f"Attempting to run utility: {script_name}...")
    try:
        process = subprocess.run(
            [sys.executable, script_path],
            cwd=project_root,
            check=False,
            capture_output=True,
            text=True,
            encoding='utf-8',
            errors='replace'
        )

        if process.stdout:
            print(f"--- Output from {script_name} ---\n{process.stdout.strip()}\n---------------------------")
        if process.stderr:
            print(f"--- Errors from {script_name} ---\n{process.stderr.strip()}\n---------------------------", file=sys.stderr)

        if process.returncode == 0:
            message = f"Utility '{script_name}' executed successfully."
            print(f"Success: {message}")
            return True, ""
        elif script_name == "run_tests.py" and process.returncode == 1:
            message = f"Utility '{script_name}' completed. Some tests failed. Results have been updated."
            print(f"Notice: {message}")
            return True, f"[NOTICE: {script_name} reported test failures. Results file updated.]\n"
        else:
            message = f"Utility '{script_name}' failed with exit code {process.returncode}."
            error_details = process.stderr.strip() if process.stderr else 'N/A'
            print(f"Error: {message}\nStderr:\n{error_details}")
            return False, f"[NOTICE: {script_name} execution failed (Code: {process.returncode}). Corresponding artifact may be stale or missing.]\n"
    except Exception as e:
        message = f"An unexpected error occurred while trying to run '{script_name}': {e}"
        print(f"Error: {message}")
        return False, f"[NOTICE: Unexpected error running {script_name}. Corresponding artifact may be stale or missing.]\n"

def _get_message_from_log_line(log_line_str: str) -> str | None:
    """Extracts the core message from a formatted log line."""
    match = LOG_MESSAGE_CAPTURE_PATTERN.match(log_line_str.strip())
    if match:
        return match.group(1).strip()
    # print(f"DEBUG: Log line did not match pattern: '{log_line_str.strip()}'") # Optional: very verbose debug
    return None

def _get_last_log_session(log_filepath: str) -> str:
    """
    Reads the specified log file and attempts to extract the last complete session.
    Returns the session content as a string, or an informational message if not found.
    """
    print(f"LogParser: Attempting to read last log session from: {log_filepath}")
    if not os.path.exists(log_filepath):
        return "[LogParser: Log file not found at specified path]\n"

    try:
        with open(log_filepath, 'r', encoding='utf-8', errors='replace') as f:
            lines = f.readlines()
    except Exception as e:
        return f"[LogParser: Error reading log file: {e}]\n"

    if not lines:
        return "[LogParser: Log file is empty]\n"

    session_end_block_indices = [] # Stores the starting index of each 4-line end block
    print(f"LogParser: Scanning {len(lines)} lines for session end markers...")
    for i in range(len(lines) - 3): # Need at least 4 lines for a complete marker block
        msg0 = _get_message_from_log_line(lines[i])
        msg1 = _get_message_from_log_line(lines[i+1])
        msg2 = _get_message_from_log_line(lines[i+2]) # Timestamp line
        msg3 = _get_message_from_log_line(lines[i+3])

        # Debug print for first few potential blocks
        # if i < 5 or i > len(lines) - 8: # Print first few and last few attempts
        #     print(f"LogParser DEBUG (End Scan) Index {i}: msg0='{msg0}', msg1='{msg1}', msg2='{msg2}', msg3='{msg3}'")

        if msg0 == LOG_SEPARATOR_LINE_TEXT and \
           msg1 == LOG_SESSION_END_TEXT and \
           (msg2 is not None and msg2.startswith(LOG_TIMESTAMP_PREFIX_TEXT)) and \
           msg3 == LOG_SEPARATOR_LINE_TEXT:
            session_end_block_indices.append(i)
            print(f"LogParser: Found potential session end block starting at line index {i}.")

    if not session_end_block_indices:
        return "[LogParser: No complete session end marker blocks found in log]\n"
    print(f"LogParser: Found {len(session_end_block_indices)} session end marker blocks.")

    last_session_end_block_start_index = session_end_block_indices[-1]
    print(f"LogParser: Last session end block starts at index {last_session_end_block_start_index}.")
    last_session_start_block_start_index = -1

    # Search backwards for the corresponding start marker block
    print(f"LogParser: Searching backwards for corresponding start marker before index {last_session_end_block_start_index}...")
    # Iterate from (last_session_end_block_start_index - 4) down to 0.
    # Each `i` is the potential start of a 4-line start block.
    for i in range(last_session_end_block_start_index - 4, -1, -1):
        if i + 3 >= len(lines): # Ensure we don't go out of bounds
            continue

        msg0 = _get_message_from_log_line(lines[i])
        msg1 = _get_message_from_log_line(lines[i+1])
        msg2 = _get_message_from_log_line(lines[i+2]) # Timestamp line
        msg3 = _get_message_from_log_line(lines[i+3])

        # Debug print for a few backward scan attempts
        # if i > last_session_end_block_start_index - 4 - 5: # Print some attempts
        #     print(f"LogParser DEBUG (Start Scan) Index {i}: msg0='{msg0}', msg1='{msg1}', msg2='{msg2}', msg3='{msg3}'")

        if msg0 == LOG_SEPARATOR_LINE_TEXT and \
           msg1 == LOG_SESSION_START_TEXT and \
           (msg2 is not None and msg2.startswith(LOG_TIMESTAMP_PREFIX_TEXT)) and \
           msg3 == LOG_SEPARATOR_LINE_TEXT:
            # Ensure this start block is actually before the end block we found
            if i < last_session_end_block_start_index:
                last_session_start_block_start_index = i
                print(f"LogParser: Found corresponding session start block at index {i}.")
                break
            else:
                print(f"LogParser DEBUG: Found start block at {i} but it's not before end block at {last_session_end_block_start_index}")


    if last_session_start_block_start_index == -1:
        return "[LogParser: Found session end, but no corresponding start marker block for the last completed session]\n"

    # Corrected slicing: Extract from the start of the "Session Started" block
    # to the end of the "Session Ended" block (inclusive of the 4 lines for each marker).
    start_index_for_slice = last_session_start_block_start_index
    # The end block starts at last_session_end_block_start_index and is 4 lines long.
    # So, it ends at line index last_session_end_block_start_index + 3.
    # The slice should go up to index+1, so last_session_end_block_start_index + 4.
    end_index_for_slice = last_session_end_block_start_index + 4

    print(f"LogParser: Extracting session from line {start_index_for_slice} to {end_index_for_slice-1}.")
    session_content_lines = lines[start_index_for_slice : end_index_for_slice]
    return "".join(session_content_lines)


# --- Main Function ---
def generate_snapshot(summary_message=None, include_logs=False):
    """Generates a snapshot file containing the content of specified project files."""
    project_root = get_project_root()
    utils_dir = os.path.join(project_root, "utils")

    snapshots_dir_path = os.path.join(project_root, SNAPSHOT_DIRECTORY)
    try:
        os.makedirs(snapshots_dir_path, exist_ok=True)
    except Exception as e:
        print(f"Error creating snapshot directory {snapshots_dir_path}: {e}")
        return None

    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    snapshot_filename = SNAPSHOT_FILENAME_TEMPLATE.format(timestamp=timestamp)
    output_filepath = os.path.join(snapshots_dir_path, snapshot_filename)

    print(f"\nGenerating snapshot for project at: {project_root}")
    if summary_message:
        print(f"With summary: {summary_message}")
    if include_logs:
        print("Including last log session.")
    print(f"Output will be saved to: {output_filepath}\n")

    snapshot_content = []
    snapshot_content.append(f"micro_X Project Snapshot\n")
    snapshot_content.append(f"Generated on: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")

    if summary_message:
        snapshot_content.append(f"Summary: {summary_message}\n")
    else:
        snapshot_content.append(f"Summary: [No summary provided for this snapshot]\n")
    
    if include_logs:
        snapshot_content.append(f"Log Inclusion: Last completed session log included.\n") # Clarified "completed"


    prerequisite_notices = []

    # --- Run prerequisite utilities ---
    # 1. Generate Project Tree
    tree_success, tree_notice = run_utility_script("generate_tree.py", project_root, utils_dir)
    if not tree_success:
        prerequisite_notices.append(tree_notice)

    # 2. Run Tests
    tests_ran_successfully, tests_notice = run_utility_script("run_tests.py", project_root, utils_dir)
    if tests_notice:
        prerequisite_notices.append(tests_notice)

    if prerequisite_notices:
        snapshot_content.append("\n--- Prerequisite Utility Status ---\n")
        snapshot_content.extend(prerequisite_notices)
        snapshot_content.append("-----------------------------------\n\n")
    else:
        snapshot_content.append("\n[All prerequisite utilities executed successfully (tests may have passed or failed as reported by the test utility).]\n\n")

    snapshot_content.append("=" * 80 + "\n\n")

    for relative_path in FILES_TO_INCLUDE:
        full_path = os.path.join(project_root, relative_path)
        snapshot_content.append(f"--- START OF FILE: {relative_path} ---\n")
        content = read_file_content(full_path)
        if content is not None:
            snapshot_content.append(content)
        else:
            snapshot_content.append(f"[Content not available or file not found: {relative_path}]\n")
        snapshot_content.append(f"\n--- END OF FILE: {relative_path} ---\n\n")
        snapshot_content.append("=" * 80 + "\n\n")

    # --- Include Last Log Session if requested ---
    if include_logs:
        log_file_full_path = os.path.join(project_root, LOG_DIR_NAME, LOG_FILE_BASENAME)
        snapshot_content.append(f"--- START OF LAST COMPLETED LOG SESSION ({LOG_FILE_BASENAME}) ---\n")
        log_session_content = _get_last_log_session(log_file_full_path)
        snapshot_content.append(log_session_content)
        snapshot_content.append(f"\n--- END OF LAST COMPLETED LOG SESSION ({LOG_FILE_BASENAME}) ---\n\n")
        snapshot_content.append("=" * 80 + "\n\n")


    try:
        with open(output_filepath, 'w', encoding='utf-8') as f:
            f.writelines(snapshot_content)
        print(f"Successfully generated snapshot: {output_filepath}")
        return output_filepath
    except Exception as e:
        print(f"Error writing snapshot file: {e}")
        return None

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Generate a snapshot of the micro_X project, optionally running prerequisite utilities and including logs.",
        formatter_class=argparse.RawTextHelpFormatter # To allow newlines in help
    )
    parser.add_argument(
        "-s", "--summary",
        type=str,
        help="A short summary or reason for generating this snapshot.\nThis will be included in the snapshot file.",
        default=None
    )
    parser.add_argument(
        "--include-logs",
        action="store_true", # Makes it a flag, True if present, False otherwise
        help="Include the last complete micro_X session from the log file\n(logs/micro_x.log) in the snapshot.",
        default=False
    )
    args = parser.parse_args()

    generated_file = generate_snapshot(summary_message=args.summary, include_logs=args.include_logs)

    if generated_file:
        print(f"\nSnapshot generation complete. File: {generated_file}")
    else:
        print("\nSnapshot generation failed.")
