#!/usr/bin/env python

import os
import datetime
import subprocess # For running other utility scripts
import sys # For using sys.executable

# --- Configuration ---
# Files and directories to include in the snapshot.
# Paths are relative to the project root (where this script's parent directory is).
FILES_TO_INCLUDE = [
    "main.py",
    "config/default_config.json",
    "config/default_command_categories.json",
    "config/.tmux.conf",
    "requirements.txt",
    "requirements-dev.txt",
    ".gitignore",
    "utils/generate_tree.py",
    "utils/generate_snapshot.py", # Include self
    "utils/install_requirements.py",
    "utils/run_tests.py", # Assuming the new test runner utility
    "project_tree.txt", # Generated by generate_tree.py
    "README.md",
    "micro_X.sh",
    "micro_X.desktop",
    "modules/ai_handler.py",
    "modules/category_manager.py",
    "modules/output_analyzer.py",
    "modules/ollama_manager.py",
    "modules/shell_engine.py",
    "modules/ui_manager.py",
    "setup_scripts/setup_micro_X_mac.sh",
    "setup_scripts/setup_micro_X_mint.sh",
    "setup_scripts/setup_micro_X_termux.sh",
    "setup_scripts/setup_micro_X_wsl.sh",
    "tests/test_ai_handler.py",
    "tests/test_category_manager.py",
    "tests/conftest.py",
    "tests/test_ui_manager.py",
    "tests/test_shell_engine.py",
    "tests/tests.md",
    "pytest_results/pytest_results.txt", # Generated by run_tests.py
    "docs/micro_X_User_Guide.md",
    "docs/setup_micro_X_mac.md",
    "docs/setup_micro_X_mint.md",
    "docs/setup_micro_X_termux.md",
    "docs/setup_micro_X_wsl.md",
    "docs/review_of_micro_X_project.md",
    "docs/micro_X_testing_guide.md",
    "setup.sh"
]

# Output directory and filename for the snapshot
SNAPSHOT_DIRECTORY = "snapshots"
SNAPSHOT_FILENAME_TEMPLATE = "micro_x_context_snapshot_{timestamp}.txt"

# --- Helper Functions ---
def get_project_root():
    """Determines the project root directory.
    Assumes this script is in a 'utils' subdirectory of the project root.
    """
    script_path = os.path.abspath(__file__)
    utils_dir = os.path.dirname(script_path)
    project_root = os.path.dirname(utils_dir)
    if os.path.exists(os.path.join(project_root, "main.py")) or \
       os.path.exists(os.path.join(project_root, ".git")): # Added .git as a common root indicator
        return project_root
    else:
        if os.path.exists(os.path.join(utils_dir, "main.py")) or \
           os.path.exists(os.path.join(utils_dir, ".git")):
            print("Warning: Script might be in project root, not utils/. Assuming current dir's parent is root.")
            return utils_dir # Script is in root
        print("Warning: Could not reliably determine project root. Using script's directory's parent.")
        return project_root


def read_file_content(filepath):
    """Reads the content of a file. Returns None if file not found or error."""
    try:
        with open(filepath, 'r', encoding='utf-8', errors='replace') as f: # Added errors='replace'
            return f.read()
    except FileNotFoundError:
        print(f"Warning: File not found - {filepath}")
        return None
    except Exception as e:
        print(f"Warning: Error reading file {filepath} - {e}")
        return None

def run_utility_script(script_name: str, project_root: str, utils_dir: str) -> tuple[bool, str]:
    """
    Runs a utility script from the utils directory.
    Returns a tuple: (success: bool, message: str)
    """
    script_path = os.path.join(utils_dir, script_name)
    if not os.path.exists(script_path):
        message = f"Utility script '{script_name}' not found at '{script_path}'. Skipping."
        print(f"Warning: {message}")
        return False, f"[NOTICE: {script_name} execution skipped - script not found.]\n"

    print(f"Attempting to run utility: {script_name}...")
    try:
        # run_tests.py already prints its own summary, so capture_output might not be essential
        # unless we want to suppress its direct console output here.
        # For simplicity, let them print to console directly for now.
        process = subprocess.run(
            [sys.executable, script_path],
            cwd=project_root,
            check=False, # Handle errors manually based on returncode
            capture_output=True, # Capture output to avoid cluttering snapshot console, log it instead
            text=True,
            encoding='utf-8',
            errors='replace'
        )
        
        # Log output from the utility script for debugging if needed
        if process.stdout:
            print(f"--- Output from {script_name} ---\n{process.stdout.strip()}\n---------------------------")
        if process.stderr:
             print(f"--- Errors from {script_name} ---\n{process.stderr.strip()}\n---------------------------", file=sys.stderr)


        if process.returncode == 0:
            message = f"Utility '{script_name}' executed successfully."
            print(f"Success: {message}")
            return True, "" # No notice needed for success
        elif script_name == "run_tests.py" and process.returncode == 1: # Pytest specific: tests failed
            message = f"Utility '{script_name}' completed. Some tests failed. Results have been updated."
            print(f"Notice: {message}")
            return True, f"[NOTICE: {script_name} reported test failures. Results file updated.]\n"
        else:
            message = f"Utility '{script_name}' failed with exit code {process.returncode}."
            print(f"Error: {message}\nStderr:\n{process.stderr.strip() if process.stderr else 'N/A'}")
            return False, f"[NOTICE: {script_name} execution failed (Code: {process.returncode}). Corresponding artifact may be stale or missing.]\n"
    except Exception as e:
        message = f"An unexpected error occurred while trying to run '{script_name}': {e}"
        print(f"Error: {message}")
        return False, f"[NOTICE: Unexpected error running {script_name}. Corresponding artifact may be stale or missing.]\n"

# --- Main Function ---
def generate_snapshot():
    """Generates a snapshot file containing the content of specified project files."""
    project_root = get_project_root()
    utils_dir = os.path.join(project_root, "utils") # Define utils_dir

    snapshots_dir_path = os.path.join(project_root, SNAPSHOT_DIRECTORY)
    try:
        os.makedirs(snapshots_dir_path, exist_ok=True)
    except Exception as e:
        print(f"Error creating snapshot directory {snapshots_dir_path}: {e}")
        return None
        
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    snapshot_filename = SNAPSHOT_FILENAME_TEMPLATE.format(timestamp=timestamp)
    output_filepath = os.path.join(snapshots_dir_path, snapshot_filename)

    print(f"\nGenerating snapshot for project at: {project_root}")
    print(f"Output will be saved to: {output_filepath}\n")

    snapshot_content = []
    snapshot_content.append(f"micro_X Project Snapshot\n")
    snapshot_content.append(f"Generated on: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
    
    prerequisite_notices = []

    # --- Run prerequisite utilities ---
    # 1. Generate Project Tree
    tree_success, tree_notice = run_utility_script("generate_tree.py", project_root, utils_dir)
    if not tree_success:
        prerequisite_notices.append(tree_notice)

    # 2. Run Tests
    tests_success, tests_notice = run_utility_script("run_tests.py", project_root, utils_dir)
    # tests_success here means the script ran; test failures (rc=1) are handled as a form of success for snapshotting
    if tests_notice: # Append notice if there's one (e.g. script failure, or test failures)
        prerequisite_notices.append(tests_notice)
    
    if prerequisite_notices:
        snapshot_content.append("\n--- Prerequisite Utility Status ---\n")
        snapshot_content.extend(prerequisite_notices)
        snapshot_content.append("-----------------------------------\n\n")
    else:
        snapshot_content.append("\n[All prerequisite utilities executed successfully.]\n\n")

    snapshot_content.append("=" * 80 + "\n\n")

    for relative_path in FILES_TO_INCLUDE:
        full_path = os.path.join(project_root, relative_path)
        
        snapshot_content.append(f"--- START OF FILE: {relative_path} ---\n")
        
        content = read_file_content(full_path)
        if content is not None:
            snapshot_content.append(content)
        else:
            snapshot_content.append(f"[Content not available or file not found: {relative_path}]\n")
        
        snapshot_content.append(f"\n--- END OF FILE: {relative_path} ---\n\n")
        snapshot_content.append("=" * 80 + "\n\n")

    try:
        with open(output_filepath, 'w', encoding='utf-8') as f:
            f.writelines(snapshot_content)
        print(f"Successfully generated snapshot: {output_filepath}")
        return output_filepath
    except Exception as e:
        print(f"Error writing snapshot file: {e}")
        return None

if __name__ == "__main__":
    generated_file = generate_snapshot()
    if generated_file:
        print(f"\nSnapshot generation complete. File: {generated_file}")
    else:
        print("\nSnapshot generation failed.")
